#    给了我们一个字符串，让我们求最长的无重复字符的子串，注意这里是子串，不是子序列，所以必须是连续的。我们先不考虑代码怎么实现，如果
# 给一个例子中的例子"abcabcbb"，让你手动找无重复字符的子串，该怎么找。博主会一个字符一个字符的遍历，比如a，b，c，然后又出现了一个a，
# 那么此时就应该去掉第一次出现的a，然后继续往后，又出现了一个b，则应该去掉一次出现的b，以此类推，最终发现最长的长度为3。所以说，我们
# 需要记录之前出现过的字符，记录的方式有很多，最常见的是统计字符出现的个数，但是这道题字符出现的位置很重要，所以我们可以使用HashMap来
# 建立字符和其出现位置之间的映射。进一步考虑，由于字符会重复出现，到底是保存所有出现的位置呢，还是只记录一个位置？我们之前手动推导的
# 方法实际上是维护了一个滑动窗口，窗口内的都是没有重复的字符，我们需要尽可能的扩大窗口的大小。由于窗口在不停向右滑动，所以我们只关心每
# 个字符最后出现的位置，并建立映射。窗口的右边界就是当前遍历到的字符的位置，为了求出窗口的大小，我们需要一个变量left来指向滑动窗口的左
# 边界，这样，如果当前遍历到的字符从未出现过，那么直接扩大右边界，如果之前出现过，那么就分两种情况，在或不在滑动窗口内，如果不在滑动窗
# 口内，那么就没事，当前字符可以加进来，如果在的话，就需要先在滑动窗口内去掉这个已经出现过的字符了，去掉的方法并不需要将左边界left一位
# 一位向右遍历查找。

class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        # sliding window  
        sub_string = ''
        max_string = ''
        for c in s:     #一个一个的取s中的值
            if c not in sub_string:
                sub_string += c   # 将不重复的村放入sub_string中
                if len(sub_string) > len(max_string):
                    max_string = sub_string   %最大的存放在max_string中
            else:
                pre_index = sub_string.index(c)   %找出sub_string和现在重复的那个的第一的位置引索
                sub_string = sub_string[pre_index + 1:] + c  #字符串可以相加
                
        return len(max_string)
